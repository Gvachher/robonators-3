#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLight,      sensorLineFollower)
#pragma config(Sensor, in2,    middleLight,    sensorLineFollower)
#pragma config(Sensor, in3,    rightLight,     sensorLineFollower)
#pragma config(Sensor, in4,    wristPot,       sensorPotentiometer)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  extensionEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl11, armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           frontRightMotor, tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rearRightMotor, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           frontLeftMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rearLeftMotor, tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port8,           leftExtendMotor, tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port9,           rightExtendMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          wristMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_5)
//*!!Code automatically generated by 'ROBOTC' configuration wizard                 !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Fantasticbot Remote Control
- This program allows you to remotely control your robot using the USB Logitech Dual
  Action Joysticks.
- This program also ignores low values that would cause your robot to move when the joysticks fail to
  return back to exact center.  You may need to adjust the 'threshold' value to get it just right.
- For USB values to be transmitted to the robot, you must follow several steps:
  - Use the "#include "JoystickDriver.c"" line at the beginning of your program
  - Call the "getJoystickSettings(joystick);" in a loop to repeatedly retrieve the latest values
  - Open the Robot > Debugger Windows > "Joystick Control - Basic" window after downloading your
    program to the virtual robot
----------------------------------------------------------------------------------------------------*/

#pragma debuggerWindows("joystickSimple");
#include "JoystickDriver.c"

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
	//Integer variable that allows you to specify a "deadzone" where values (both positive or negative)
  //less than the threshold will be ignored.
  int threshold = 10;
 int xx;
 int yy;
  //Loop Forever
  while(1 == 1)
  {
    //Get the Latest joystick values
    getJoystickSettings(joystick);

    //DRIVE

		//Arm Control
    if(joy1Btn(Btn1) == true)       //If button 6 is pressed...
    {
      motor[armMotor] = 127;      //...raise the arm.
    }
    else if(joy1Btn(8) == 1)  //Else, if button 8 is pressed...
    {
      motor[armMotor] = -63;     //...lower the arm.
    }
    else                      //Else (neither button is pressed)...
    {
      motor[armMotor] = 0;       //...stop the arm.
    }

    //Claw Control
    if(joy1Btn(5) == 1)       //If Button 5 is pressed...
    {
      motor[clawMotor] = 127;     //...close the claw.
    }
    else if(joy1Btn(7) == 1)  //Else, if button 7 is pressed...
    {
      motor[clawMotor] = -127;     //...open the claw.
    }
    else                      //Else (neither button is pressed)...
    {
      motor[clawMotor] = 0;       //...stop the claw.
    }

    //Extension Control
    if(joy1Btn(4) == 1)       //If Button 4 is pressed...
    {
      motor[leftExtendMotor] = 127;     //...extend the arm.
      motor[rightExtendMotor] = 127;
    }
    else if(joy1Btn(2) == 1)  //Else, if button 2 is pressed...
    {
      motor[leftExtendMotor] = -127;     //...retract the arm.
      motor[rightExtendMotor] = -127;
    }
    else                      //Else (neither button is pressed)...
    {
      motor[leftExtendMotor] = 0;     //...stop extending/retracting the arm.
      motor[rightExtendMotor] = 0;
    }

    //Wrist Control
    if(joy1Btn(1) == 1)       //If Button 1 is pressed...
    {
      motor[wristMotor] = 127;     //...turn the wrist up.
    }
    else if(joy1Btn(3) == 1)  //Else, if button 3 is pressed...
    {
      motor[wristMotor] = -127;     //...turn the wrist down.
    }
    else                      //Else (neither button is pressed)...
    {
      motor[wristMotor] = 0;       //...stop the wrist.
    }

    // DRIVE
  	if(abs(joystick.joy1_y1) > threshold || abs(joystick.joy1_x1) > threshold)
  	{
			  //first quadrant

  	    // check for quadrant 1; rememberr that forntRightMotor was -2xx+ 127;
   					xx = joystick.joy1_x1;
  	    		yy = joystick.joy1_y1;
  	    		if( (xx >  0)&&(xx < 127)&&(yy > 0)&& (yy < 127) )
  	    			{
  	    	  motor[frontRightMotor] = -2*xx + 127;
  	    	  motor[frontLeftMotor] = 127;
  	    	}

  	    // check for quadrant 1; rememberr that forntRightMotor was -2xx+ 127;
   	    		if( (xx > -127 )&&(xx < 0)&&(yy > 0)&& (yy < 127) )
  	    			{
  	    	  motor[frontRightMotor] = 127;
  	    	  motor[frontLeftMotor] = 2*xx + 127;
  	  	}

  	    // 3rd quadrant
  	    		if( (xx > -127)&&(xx < 0)&&(yy < 0)&& (yy > -127) )
  	    			{
  	    	  motor[frontRightMotor] = -2*xx - 127;
  	    	  motor[frontLeftMotor] = -127;
  	    	}

  	    // check for quadrant 1; rememberr that forntRightMotor was -2xx+ 127;
  	    		if( (xx > 0)&&(xx < 127)&&(yy < 0)&& (yy > -127) )
  	    			{
  	    	  motor[frontRightMotor] = 2*xx - 127;
  	    	  motor[frontLeftMotor] = -127;
  	    	}
	  	}
  	   else                                      // Else the readings are within the threshold, so
	    {
      motor[rearRightMotor] = 0;                  // ...the right motors and left motors are stopped with a power level of 0.
    	motor[frontRightMotor] = 0;
    	motor[rearLeftMotor] = 0;
    	motor[frontLeftMotor] = 0;
     }


  }
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
