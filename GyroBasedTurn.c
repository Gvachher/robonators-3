#pragma config(StandardModel, "RVW SQUAREBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void moveForward(int secs)
{
	motor(rightMotor) = -127;
	motor(leftMotor) = -127;

	wait1Msec(secs);
}

void moveBackward(int secs)
{
	motor(rightMotor) = 127;
	motor(leftMotor) = 127;
	// wait here for 'secs' millisecs
	wait1Msec(secs);
}

void turnLeft(int secs)
{
	motor(rightMotor) = 70;
	motor(leftMotor) = -90;
	wait1Msec(secs);
}

void pause(int secs)
{
	motor(rightMotor) = 0;
	motor(leftMotor) = 0;
	wait1Msec(secs);

}

void turnRight(int secs)
{
	motor(rightMotor) = -90;
	motor(leftMotor) = 70;

	wait1Msec(secs);
}

void moveFoward(int secs)
{
	motor(RightMotor) = 55;
	motor(LeftMotor) = 55;
	motor(LeftMotor) = 55;
	motor(RightMotor) = 55;
	wait1Msec(secs);
}

void turnLeft(int secs)
{
	motor(rightMotor) = 90;
	motor(LeftMotor) = -90;
	motor(LeftMotor) = -90;
	motor(RightMotor) = 90;
	wait1Msec(secs);
}

void stop(int secs)
{
	motor[LeftMotor] = 0;
	motor[RightMotor] = 0;

}
//gyro based turn
//Completely clear out any previous sensor readings by setting the port to "sensorNone"
void GyroBasedTurns(int degrees, int initial)
{
	int finalvalue;

	pause(100);
	SensorType[in4] = sensorNone;
	wait1Msec(100);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	pause(100);
	SensorType[in4] = sensorGyro;
	wait1Msec(200);
	SensorFullCount[in4] = 36000;

	//Adjust SensorScale to correct the scaling for your gyro
	//SensorScale[in8] = 260;
	//Adjust SensorFullCount to set the "rollover" point. A value of 3600 sets the rollover point to +/-3600
	//SensorFullCount[in8] = 3600;
	int degreesX = 10*degrees ;
	initial = SensorValue[in4];
	//Specify the number of degrees for the robot to turn (1 degree = 10, or 900 = 90 degrees)

	//  SensorValue[in4] = 0;

 finalvalue = ((initial - degreesX) );
	//While the absolute value of the gyro is less than the desired rotation...
  //	while( abs(SensorValue[in4]) < ((initial)- degreesX)
	while( SensorValue[in4] > finalvalue)
	{
		//...continue turning
		motor[RightMotor] = 35;
		motor[LeftMotor] = -35;
		if ( SensorValue[in4] < -3597 ){
			writeDebugStreamLine("The gyro value at %d seconds is %d", degrees, SensorValue[gyro]);
		}
	}
	// motor[RightMotor] = 0;
	// motor[LeftMotor] = 0;
	// wait1Msec(250);
}

void GoToLineAndCross()
{
	while(sensorValue[centerLineFollower]< 700)
	{
		moveBackward(1);
	}
	pause(1);
	// move while black line/area
	pause(1);
	while (sensorValue[centerLineFollower]> 530)
	{
		moveBackward(1);
	}
}

void GoToLineAndTurnBack()
{
	while(sensorValue[centerLineFollower]< 700)
	{
		moveBackward(1);
	}
	pause(1);
	GyroBasedTurns(180,0);
}

void GoToStartAndTurnBack()
{
	while(sensorValue[centerLineFollower]< 575)
	{
		moveBackward(1);
	}
	pause(1);
	GyroBasedTurns(180,0);
}




task main()

{
	int i;
	int j;
	// move while white area
	// while(sensorValue[centerLineFollower]< 625)
	// {
	//   moveBackward(1);
	// }
	// pause(1);
	// move while black line/area
	// while (sensorValue[centerLineFollower]> 530)
	//{
	//  moveBackward(1);
	//}

	//while(sensorValue[centerLineFollower]< 600 )
	//{
	//  moveBackward(1);

	//
	// pause(1);
	for( j=0; j<3; j++)
	{
		if(j>0)
		{
			GoToLineAndCross();
  	}
  	if(j>1)
   {
  		GoToLineAndCross();
	 }
	 GoToLineAndTurnBack();
	  if(j>0)
	  {
//	  	GoToLineAndCross();
	  }
		if (j>1)
	  {
	    GoToLineAndCross();
	  }

	  // Punit changed the function name. please copy the GoToLineAndTurnBack and then edit the new function
	  // to look for a grey line. 8/24/2018

	  GoToStartAndTurnBack();
	}
}
